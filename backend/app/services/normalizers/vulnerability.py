import re
from typing import Any, Dict, List, Optional, Set, TYPE_CHECKING

from app.models.finding import Finding, FindingType, Severity
from app.services.normalizers.utils import (
    build_finding_id,
    extract_cvss,
    extract_grype_cvss,
    safe_get,
    safe_severity,
)

if TYPE_CHECKING:
    from app.services.aggregator import ResultAggregator


def normalize_trivy(
    aggregator: "ResultAggregator", result: Dict[str, Any], source: Optional[str] = None
):
    """Normalize Trivy vulnerability scan results."""
    # Trivy structure: {"Results": [{"Vulnerabilities": [...]}]}
    if "Results" not in result:
        return

    for target in result.get("Results", []):
        for vuln in target.get("Vulnerabilities") or []:
            # Extract extra details
            references = vuln.get("References") or []
            published_date = vuln.get("PublishedDate")
            last_modified_date = vuln.get("LastModifiedDate")
            cwe_ids = vuln.get("CweIDs") or []

            # Extract aliases from references
            aliases: Set[str] = set()
            vuln_id = vuln.get("VulnerabilityID", "")

            for ref in references:
                match = re.search(r"(CVE-\d{4}-\d{4,})", ref)
                if match:
                    cve = match.group(1)
                    if cve != vuln_id:
                        aliases.add(cve)

            # ID Normalization: Prefer CVE if available in aliases
            aliases_list = list(aliases)
            cve_alias = next((a for a in aliases_list if a.startswith("CVE-")), None)

            if cve_alias and vuln_id and not vuln_id.startswith("CVE-"):
                if vuln_id not in aliases_list:
                    aliases_list.append(vuln_id)
                vuln_id = cve_alias

            # CVSS Parsing using shared utility
            cvss_score, cvss_vector = extract_cvss(vuln.get("CVSS", {}))

            # Construct description: Title + Description for maximum context
            title = (vuln.get("Title") or "").strip()
            desc = (vuln.get("Description") or "").strip()

            if title and desc:
                # Check if title is just a truncated or full version of the description
                clean_title = title.rstrip("...").strip()
                if clean_title in desc:
                    final_desc = desc
                else:
                    final_desc = f"{title}\n\n{desc}"
            else:
                final_desc = desc or title or ""

            aggregator.add_finding(
                Finding(
                    id=vuln_id or build_finding_id("VULN", vuln.get("PkgName")),
                    type=FindingType.VULNERABILITY,
                    severity=safe_severity(vuln.get("Severity")),
                    component=vuln.get("PkgName"),
                    version=vuln.get("InstalledVersion"),
                    description=final_desc,
                    scanners=["trivy"],
                    details={
                        "fixed_version": vuln.get("FixedVersion"),
                        "cvss_score": cvss_score,
                        "cvss_vector": cvss_vector,
                        "references": references,
                        "published_date": published_date,
                        "last_modified_date": last_modified_date,
                        "cwe_ids": cwe_ids,
                        "layer_id": safe_get(vuln.get("Layer", {}), "Digest", None),
                    },
                    aliases=aliases_list,
                ),
                source=source,
            )


def normalize_grype(
    aggregator: "ResultAggregator", result: Dict[str, Any], source: Optional[str] = None
):
    """Normalize Grype vulnerability scan results."""
    # Grype structure: {"matches": [{"vulnerability": {...}, "artifact": {...}}]}
    for match in result.get("matches") or []:
        vuln = match.get("vulnerability") or {}
        artifact = match.get("artifact") or {}

        # ID Normalization: Prefer CVE if available in aliases
        vuln_id = vuln.get("id", "")
        aliases: List[str] = [
            r.get("id") for r in vuln.get("relatedVulnerabilities") or [] if r.get("id")
        ]

        # If current ID is GHSA/GO/etc and a CVE exists in aliases, use CVE as primary ID
        cve_alias = next((a for a in aliases if a.startswith("CVE-")), None)
        if cve_alias and vuln_id and not vuln_id.startswith("CVE-"):
            if vuln_id not in aliases:
                aliases.append(vuln_id)
            vuln_id = cve_alias

        # CVSS Parsing using shared utility
        cvss_score, cvss_vector = extract_grype_cvss(vuln.get("cvss") or [])

        # Build fixed version string
        fix_versions = safe_get(vuln.get("fix", {}), "versions", [])
        fixed_version = ", ".join(fix_versions) if fix_versions else None

        aggregator.add_finding(
            Finding(
                id=vuln_id or build_finding_id("VULN", artifact.get("name")),
                type=FindingType.VULNERABILITY,
                severity=safe_severity(vuln.get("severity")),
                component=artifact.get("name"),
                version=artifact.get("version"),
                description=vuln.get("description") or "",
                scanners=["grype"],
                details={
                    "fixed_version": fixed_version,
                    "datasource": vuln.get("dataSource"),
                    "references": vuln.get("urls") or [],
                    "cvss_score": cvss_score,
                    "cvss_vector": cvss_vector,
                    "namespace": vuln.get("namespace"),
                },
                aliases=aliases,
            ),
            source=source,
        )


def _process_osv_malware(
    aggregator: "ResultAggregator",
    vuln: Dict[str, Any],
    comp_name: str,
    comp_version: str,
    source: Optional[str] = None,
):
    """
    Handle OpenSSF malicious-packages entries (MAL- prefix) from OSV.dev.
    These are not vulnerabilities but confirmed malware.
    """
    vuln_id = vuln.get("id", "")

    # Extract affected versions
    affected_versions: List[str] = []
    for affected in vuln.get("affected") or []:
        versions = affected.get("versions") or []
        affected_versions.extend(versions)

    # Build references list
    references: List[str] = []
    for ref in vuln.get("references") or []:
        url = ref.get("url")
        if url:
            references.append(url)

    description = (
        vuln.get("summary") or vuln.get("details") or "Malicious package detected"
    )

    aggregator.add_finding(
        Finding(
            id=build_finding_id("MALWARE", comp_name),
            type=FindingType.MALWARE,
            severity=Severity.CRITICAL,
            component=comp_name,
            version=comp_version,
            description=f"[{vuln_id}] {description}",
            scanners=["osv"],
            details={
                "osv_id": vuln_id,
                "source": "openssf",
                "reference": references[0] if references else None,
                "references": references,
                "published": vuln.get("published"),
                "modified": vuln.get("modified"),
                "affected_versions": affected_versions[:10],
                "osv_url": f"https://osv.dev/vulnerability/{vuln_id}",
            },
        ),
        source=source,
    )


def normalize_osv(
    aggregator: "ResultAggregator", result: Dict[str, Any], source: Optional[str] = None
):
    """Normalize OSV vulnerability scan results."""
    # OSV structure: {"osv_vulnerabilities": [{"component":..., "vulnerabilities": [...]}]}
    for item in result.get("osv_vulnerabilities") or []:
        comp_name = item.get("component")
        comp_version = item.get("version")

        for vuln in item.get("vulnerabilities") or []:
            vuln_id = vuln.get("id", "")

            # Check if this is a malware entry from OpenSSF (MAL- prefix)
            if vuln_id.startswith("MAL-"):
                _process_osv_malware(aggregator, vuln, comp_name, comp_version, source)
                continue

            # 1. Determine Severity
            severity_str = "UNKNOWN"

            # Check database_specific (common in GHSA)
            db_specific = vuln.get("database_specific") or {}
            if "severity" in db_specific:
                severity_str = db_specific["severity"]

            # 2. Extract Fixed Version
            fixed_version = None
            for affected in vuln.get("affected") or []:
                # We assume the first fixed event we find is relevant
                for r in affected.get("ranges") or []:
                    for event in r.get("events") or []:
                        if "fixed" in event:
                            fixed_version = event["fixed"]
                            break
                    if fixed_version:
                        break
                if fixed_version:
                    break

            # 3. ID Normalization: Prefer CVE if available in aliases
            aliases: List[str] = list(vuln.get("aliases") or [])

            # Handle prefixed CVEs like DEBIAN-CVE-2025-10148
            if vuln_id and "CVE-" in vuln_id and not vuln_id.startswith("CVE-"):
                # Try to extract CVE
                match = re.search(r"(CVE-\d{4}-\d{4,})", vuln_id)
                if match:
                    cve_extracted = match.group(1)
                    if vuln_id not in aliases:
                        aliases.append(vuln_id)
                    vuln_id = cve_extracted

            # If current ID is GHSA/GO/etc and a CVE exists in aliases, use CVE as primary ID
            cve_alias = next((a for a in aliases if a.startswith("CVE-")), None)
            if cve_alias and vuln_id and not vuln_id.startswith("CVE-"):
                # Add original ID to aliases list to preserve it
                if vuln_id not in aliases:
                    aliases.append(vuln_id)
                vuln_id = cve_alias

            aggregator.add_finding(
                Finding(
                    id=vuln_id or build_finding_id("VULN", comp_name),
                    type=FindingType.VULNERABILITY,
                    severity=safe_severity(severity_str),
                    component=comp_name,
                    version=comp_version,
                    description=vuln.get("summary") or vuln.get("details") or "",
                    scanners=["osv"],
                    details={
                        "fixed_version": fixed_version,
                        "references": vuln.get("references"),
                        "published": vuln.get("published"),
                        "modified": vuln.get("modified"),
                        "osv_url": f"https://osv.dev/vulnerability/{vuln.get('id')}",
                    },
                    aliases=aliases,
                ),
                source=source,
            )
