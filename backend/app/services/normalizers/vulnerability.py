import re
from typing import Any, Dict, Optional, TYPE_CHECKING
from app.models.finding import Finding, FindingType, Severity

if TYPE_CHECKING:
    from app.services.aggregator import ResultAggregator


def normalize_trivy(
    aggregator: "ResultAggregator", result: Dict[str, Any], source: Optional[str] = None
):
    # Trivy structure: {"Results": [{"Vulnerabilities": [...]}]}
    if "Results" not in result:
        return

    for target in result.get("Results", []):
        for vuln in target.get("Vulnerabilities", []):
            # Extract extra details
            references = vuln.get("References", [])
            published_date = vuln.get("PublishedDate")
            last_modified_date = vuln.get("LastModifiedDate")
            cwe_ids = vuln.get("CweIDs", [])

            # Extract aliases from references
            aliases = set()
            vuln_id = vuln.get("VulnerabilityID")

            for ref in references:
                match = re.search(r"(CVE-\d{4}-\d{4,})", ref)
                if match:
                    cve = match.group(1)
                    if cve != vuln_id:
                        aliases.add(cve)

            # ID Normalization: Prefer CVE if available in aliases
            aliases_list = list(aliases)
            cve_alias = next((a for a in aliases_list if a.startswith("CVE-")), None)

            if cve_alias and vuln_id and not vuln_id.startswith("CVE-"):
                if vuln_id not in aliases_list:
                    aliases_list.append(vuln_id)
                vuln_id = cve_alias

            # CVSS Parsing
            cvss_score = None
            cvss_vector = None
            if "CVSS" in vuln:
                # Trivy CVSS structure varies, usually {"nvd": {"V3Score": ...}, "redhat": ...}
                # We prefer NVD V3, then V2, then Vendor
                for source_cvss in ["nvd", "redhat", "ghsa", "bitnami"]:
                    if source_cvss in vuln["CVSS"]:
                        data = vuln["CVSS"][source_cvss]
                        if "V3Score" in data:
                            cvss_score = data["V3Score"]
                            cvss_vector = data.get("V3Vector")
                            break
                        elif "V2Score" in data and cvss_score is None:
                            cvss_score = data["V2Score"]
                            cvss_vector = data.get("V2Vector")

            # Construct description: Title + Description for maximum context
            title = vuln.get("Title", "").strip()
            desc = vuln.get("Description", "").strip()

            if title and desc:
                # Check if title is just a truncated or full version of the description
                clean_title = title
                if title.endswith("..."):
                    clean_title = title[:-3].strip()

                if clean_title in desc:
                    final_desc = desc
                else:
                    final_desc = f"{title}\n\n{desc}"
            else:
                final_desc = desc or title or ""

            aggregator.add_finding(
                Finding(
                    id=vuln_id,
                    type=FindingType.VULNERABILITY,
                    severity=Severity(vuln.get("Severity", "UNKNOWN").upper()),
                    component=vuln.get("PkgName"),
                    version=vuln.get("InstalledVersion"),
                    description=final_desc,
                    scanners=["trivy"],
                    details={
                        "fixed_version": vuln.get("FixedVersion"),
                        "cvss_score": cvss_score,
                        "cvss_vector": cvss_vector,
                        "references": references,
                        "published_date": published_date,
                        "last_modified_date": last_modified_date,
                        "cwe_ids": cwe_ids,
                        "layer_id": vuln.get("Layer", {}).get("Digest"),
                    },
                    aliases=aliases_list,
                ),
                source=source,
            )


def normalize_grype(
    aggregator: "ResultAggregator", result: Dict[str, Any], source: Optional[str] = None
):
    # Grype structure: {"matches": [{"vulnerability": {...}, "artifact": {...}}]}
    for match in result.get("matches", []):
        vuln = match.get("vulnerability", {})
        artifact = match.get("artifact", {})

        # ID Normalization: Prefer CVE if available in aliases
        vuln_id = vuln.get("id")
        aliases = [
            r.get("id") for r in vuln.get("relatedVulnerabilities", []) if r.get("id")
        ]

        # If current ID is GHSA/GO/etc and a CVE exists in aliases, use CVE as primary ID
        cve_alias = next((a for a in aliases if a.startswith("CVE-")), None)
        if cve_alias and vuln_id and not vuln_id.startswith("CVE-"):
            if vuln_id not in aliases:
                aliases.append(vuln_id)
            vuln_id = cve_alias

        # CVSS Parsing
        cvss_score = None
        cvss_vector = None
        if "cvss" in vuln:
            # Grype CVSS is a list of objects
            # We look for the highest version (3.1 > 3.0 > 2.0)
            best_cvss = None
            for cvss in vuln["cvss"]:
                version = cvss.get("version", "0.0")
                if best_cvss is None or version > best_cvss.get("version", "0.0"):
                    best_cvss = cvss

            if best_cvss:
                cvss_score = float(best_cvss.get("metrics", {}).get("baseScore", 0))
                cvss_vector = best_cvss.get("vector")

        aggregator.add_finding(
            Finding(
                id=vuln_id,
                type=FindingType.VULNERABILITY,
                severity=Severity(vuln.get("severity", "UNKNOWN").upper()),
                component=artifact.get("name"),
                version=artifact.get("version"),
                description=vuln.get("description", ""),
                scanners=["grype"],
                details={
                    "fixed_version": ", ".join(vuln.get("fix", {}).get("versions", [])),
                    "datasource": vuln.get("dataSource"),
                    "references": vuln.get("urls", []),
                    "cvss_score": cvss_score,
                    "cvss_vector": cvss_vector,
                    "namespace": vuln.get("namespace"),
                },
                aliases=aliases,
            ),
            source=source,
        )


def _process_osv_malware(
    aggregator: "ResultAggregator",
    vuln: Dict[str, Any],
    comp_name: str,
    comp_version: str,
    source: Optional[str] = None,
):
    """
    Handle OpenSSF malicious-packages entries (MAL- prefix) from OSV.dev.
    These are not vulnerabilities but confirmed malware.
    """
    vuln_id = vuln.get("id", "")

    # Extract affected versions
    affected_versions = []
    for affected in vuln.get("affected", []):
        versions = affected.get("versions", [])
        affected_versions.extend(versions)

    # Build references list
    references = []
    for ref in vuln.get("references", []):
        if ref.get("url"):
            references.append(ref["url"])

    description = vuln.get("summary") or vuln.get(
        "details", "Malicious package detected"
    )

    aggregator.add_finding(
        Finding(
            id=f"MALWARE-{comp_name}",
            type=FindingType.MALWARE,
            severity=Severity.CRITICAL,
            component=comp_name,
            version=comp_version,
            description=f"[{vuln_id}] {description}",
            scanners=["osv"],
            details={
                "osv_id": vuln_id,
                "source": "openssf",
                "reference": references[0] if references else None,
                "references": references,
                "published": vuln.get("published"),
                "modified": vuln.get("modified"),
                "affected_versions": affected_versions[:10],
                "osv_url": f"https://osv.dev/vulnerability/{vuln_id}",
            },
        ),
        source=source,
    )


def normalize_osv(
    aggregator: "ResultAggregator", result: Dict[str, Any], source: Optional[str] = None
):
    # OSV structure: {"osv_vulnerabilities": [{"component":..., "vulnerabilities": [...]}]}
    for item in result.get("osv_vulnerabilities", []):
        comp_name = item.get("component")
        comp_version = item.get("version")

        for vuln in item.get("vulnerabilities", []):
            vuln_id = vuln.get("id", "")

            # Check if this is a malware entry from OpenSSF (MAL- prefix)
            if vuln_id.startswith("MAL-"):
                _process_osv_malware(aggregator, vuln, comp_name, comp_version, source)
                continue

            # 1. Determine Severity
            severity = "UNKNOWN"

            # Check database_specific (common in GHSA)
            if "database_specific" in vuln and "severity" in vuln["database_specific"]:
                severity = vuln["database_specific"]["severity"].upper()

            # Map OSV specific terms
            if severity == "MODERATE":
                severity = "MEDIUM"

            # 2. Extract Fixed Version
            fixed_version = None
            if "affected" in vuln:
                for affected in vuln["affected"]:
                    # We assume the first fixed event we find is relevant
                    if "ranges" in affected:
                        for r in affected["ranges"]:
                            if "events" in r:
                                for event in r["events"]:
                                    if "fixed" in event:
                                        fixed_version = event["fixed"]
                                        break
                            if fixed_version:
                                break
                    if fixed_version:
                        break

            # 3. ID Normalization: Prefer CVE if available in aliases
            aliases = vuln.get("aliases", [])

            # Handle prefixed CVEs like DEBIAN-CVE-2025-10148
            if vuln_id and "CVE-" in vuln_id and not vuln_id.startswith("CVE-"):
                # Try to extract CVE
                match = re.search(r"(CVE-\d{4}-\d{4,})", vuln_id)
                if match:
                    cve_extracted = match.group(1)
                    if vuln_id not in aliases:
                        aliases.append(vuln_id)
                    vuln_id = cve_extracted

            # If current ID is GHSA/GO/etc and a CVE exists in aliases, use CVE as primary ID
            cve_alias = next((a for a in aliases if a.startswith("CVE-")), None)
            if cve_alias and vuln_id and not vuln_id.startswith("CVE-"):
                # Add original ID to aliases list to preserve it
                if vuln_id not in aliases:
                    aliases.append(vuln_id)
                vuln_id = cve_alias

            aggregator.add_finding(
                Finding(
                    id=vuln_id,
                    type=FindingType.VULNERABILITY,
                    severity=Severity(severity),
                    component=comp_name,
                    version=comp_version,
                    description=vuln.get("summary") or vuln.get("details", ""),
                    scanners=["osv"],
                    details={
                        "fixed_version": fixed_version,
                        "references": vuln.get("references"),
                        "published": vuln.get("published"),
                        "modified": vuln.get("modified"),
                        "osv_url": f"https://osv.dev/vulnerability/{vuln.get('id')}",
                    },
                    aliases=aliases,
                ),
                source=source,
            )
