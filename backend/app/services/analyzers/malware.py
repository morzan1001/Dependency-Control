import asyncio
import logging
from typing import Any, Dict, List, Optional

import httpx

from app.core.cache import CacheKeys, CacheTTL, cache_service

from .base import Analyzer
from .purl_utils import get_purl_type, get_registry_system

logger = logging.getLogger(__name__)


class OpenSourceMalwareAnalyzer(Analyzer):
    """
    Analyzer that checks packages against the OpenSourceMalware.com API.

    This service provides real-time malware detection for npm, PyPI, and other registries.
    Requires an API key from https://opensourcemalware.com/api-tokens
    """

    name = "os_malware"
    api_url = "https://api.opensourcemalware.com/functions/v1/check-package-malicious"

    async def analyze(
        self,
        sbom: Dict[str, Any],
        settings: Dict[str, Any] = None,
        parsed_components: List[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        # Try to get key from passed settings (DB), fallback to env var
        api_key = None
        if settings and settings.get("open_source_malware_api_key"):
            api_key = settings.get("open_source_malware_api_key")

        if not api_key:
            from app.core.config import settings as env_settings

            api_key = env_settings.OPEN_SOURCE_MALWARE_API_KEY

        if not api_key:
            logger.debug("Skipping OpenSourceMalware analysis: API Key not configured.")
            return {
                "malware_issues": [],
                "skipped": True,
                "reason": "API Key not configured",
            }

        # Store key for internal use
        self.api_key = api_key

        components = self._get_components(sbom, parsed_components)
        results = []

        async with httpx.AsyncClient(timeout=30.0) as client:
            # Process in batches to avoid overwhelming the API
            batch_size = 20
            for i in range(0, len(components), batch_size):
                batch = components[i : i + batch_size]
                tasks = [
                    self._check_component(client, component) for component in batch
                ]

                # Run checks concurrently within batch
                component_results = await asyncio.gather(*tasks, return_exceptions=True)

                # Filter out None results and exceptions
                for result in component_results:
                    if result and not isinstance(result, Exception):
                        results.append(result)

                # Small delay between batches
                if i + batch_size < len(components):
                    await asyncio.sleep(0.2)

        return {"malware_issues": results}

    async def _check_component(
        self, client: httpx.AsyncClient, component: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        name = component.get("name", "")
        version = component.get("version", "")
        purl = component.get("purl", "")

        # Use centralized PURL parsing to determine registry
        registry = get_registry_system(purl) or "unknown"

        if registry == "unknown":
            # Try to guess from component type if available
            comp_type = component.get("type", "")
            type_to_registry = {
                "python": "pypi",
                "npm": "npm",
                "java-archive": "maven",
            }
            registry = type_to_registry.get(comp_type, "unknown")

        if not name or registry == "unknown":
            return None

        # Check cache first
        cache_key = CacheKeys.malware(registry, name, version)
        cached_result = await cache_service.get(cache_key)

        if cached_result is not None:
            if cached_result:  # Not a negative cache entry
                return cached_result
            return None  # Cached as safe

        try:
            payload = {"package_name": name, "registry": registry, "version": version}
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json",
            }

            response = await client.post(self.api_url, json=payload, headers=headers)

            if response.status_code == 200:
                data = response.json()
                # Process API response - check for malicious indicators
                if (
                    data.get("malicious")
                    or data.get("is_malicious")
                    or data.get("threats")
                ):
                    result = {
                        "component": name,
                        "version": version,
                        "registry": registry,
                        "source": "opensourcemalware",
                        "malware_info": {
                            "malicious": data.get("malicious")
                            or data.get("is_malicious", True),
                            "threats": data.get("threats", []),
                            "severity": data.get("severity", "critical"),
                            "description": data.get("description")
                            or data.get("threat_description"),
                            "reference": data.get("reference")
                            or data.get("osv_advisory_url"),
                            "first_seen": data.get("first_seen"),
                            "last_seen": data.get("last_seen"),
                        },
                    }
                    # Cache malicious result
                    await cache_service.set(cache_key, result, CacheTTL.MALWARE_CHECK)
                    return result
                else:
                    # Cache negative result (package is safe)
                    await cache_service.set(cache_key, {}, CacheTTL.MALWARE_CHECK)
            elif response.status_code == 404:
                # Package not found in malware db -> likely safe, cache it
                await cache_service.set(cache_key, {}, CacheTTL.MALWARE_CHECK)
            elif response.status_code == 429:
                logger.warning("Rate limited by OpenSourceMalware API")
            else:
                logger.debug(
                    f"OpenSourceMalware check for {name}: {response.status_code}"
                )

        except httpx.TimeoutException:
            logger.debug(f"Timeout checking {name} against OpenSourceMalware")
        except Exception as e:
            logger.debug(f"Exception checking {name} against OpenSourceMalware: {e}")

        return None
