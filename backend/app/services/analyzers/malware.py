import asyncio
import logging
from typing import Any, Dict, List, Optional

import httpx

from app.core.cache import CacheKeys, CacheTTL, cache_service
from app.core.http_utils import InstrumentedAsyncClient
from app.core.constants import ANALYZER_BATCH_SIZES, ANALYZER_TIMEOUTS, MALWARE_API_URL
from app.models.finding import Severity

from .base import Analyzer
from .purl_utils import parse_purl

logger = logging.getLogger(__name__)


class OpenSourceMalwareAnalyzer(Analyzer):
    """
    Analyzer that checks packages against the OpenSourceMalware.com API.

    This service provides real-time malware detection for npm, PyPI, and other registries.
    Requires an API key from https://opensourcemalware.com/api-tokens
    """

    name = "os_malware"
    api_url = MALWARE_API_URL

    async def analyze(
        self,
        sbom: Dict[str, Any],
        settings: Optional[Dict[str, Any]] = None,
        parsed_components: Optional[List[Dict[str, Any]]] = None,
    ) -> Dict[str, Any]:
        api_key = None
        if settings and settings.get("open_source_malware_api_key"):
            api_key = settings.get("open_source_malware_api_key")

        if not api_key:
            logger.debug("Skipping OpenSourceMalware analysis: API Key not configured.")
            return {
                "malware_issues": [],
                "skipped": True,
                "reason": "API Key not configured",
            }

        self.api_key = api_key

        components = self._get_components(sbom, parsed_components)
        results = []
        timeout = ANALYZER_TIMEOUTS.get("malware", ANALYZER_TIMEOUTS["default"])
        batch_size = ANALYZER_BATCH_SIZES.get("malware", 20)

        async with InstrumentedAsyncClient("OpenSourceMalware API", timeout=timeout) as client:
            for i in range(0, len(components), batch_size):
                batch = components[i : i + batch_size]
                tasks = [self._check_component(client, component) for component in batch]

                component_results = await asyncio.gather(*tasks, return_exceptions=True)

                for result in component_results:
                    if result and not isinstance(result, Exception):
                        results.append(result)

                if i + batch_size < len(components):
                    await asyncio.sleep(0.2)

        return {"malware_issues": results}

    async def _check_component(self, client: httpx.AsyncClient, component: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        name = component.get("name", "")
        version = component.get("version", "")
        purl = component.get("purl", "")

        registry = "unknown"
        if purl:
            purl_params = parse_purl(purl)
            if purl_params and purl_params.registry_system:
                registry = purl_params.registry_system

        if registry == "unknown":
            comp_type = component.get("type", "")
            type_to_registry = {
                "python": "pypi",
                "npm": "npm",
                "java-archive": "maven",
            }
            registry = type_to_registry.get(comp_type, "unknown")

        if not name or registry == "unknown":
            return None

        cache_key = CacheKeys.malware(registry, name, version)

        async def fetch_malware_status() -> Optional[Dict[str, Any]]:
            """Fetch malware status from OpenSourceMalware API."""
            try:
                query_params = {
                    "report_type": "package",
                    "resource_identifier": name,
                    "ecosystem": registry,
                }
                if version:
                    query_params["version"] = version

                headers = {
                    "Authorization": f"Bearer {self.api_key}",
                    "Content-Type": "application/json",
                }

                response = await client.get(self.api_url, params=query_params, headers=headers)

                if response.status_code == 200:
                    data = response.json()
                    if data.get("malicious"):
                        details = data.get("details", {})
                        # Normalize API severity to our Severity enum
                        api_severity = details.get("severity_level", "critical").upper()
                        try:
                            severity = Severity[api_severity].value
                        except KeyError:
                            severity = Severity.CRITICAL.value
                        return {
                            "component": name,
                            "version": version,
                            "registry": registry,
                            "source": "opensourcemalware",
                            "severity": severity,
                            "malware_info": {
                                "malicious": True,
                                "threats": details.get("tags", []),
                                "description": details.get("description"),
                                "reference": f"https://opensourcemalware.com/reports/{details.get('id')}",
                                "first_seen": details.get("first_seen"),
                                "last_seen": details.get("last_seen"),
                            },
                            "message": f"Malware detected: {details.get('description', 'Known malicious package')}",
                        }
                    else:
                        return {}  # Empty dict for negative cache (not malicious)
                elif response.status_code == 404:
                    # Package not found in malware db -> likely safe
                    return {}  # Empty dict for negative cache
                elif response.status_code == 429:
                    logger.warning("Rate limited by OpenSourceMalware API")
                    return None  # Don't cache rate limit errors
                else:
                    logger.debug(f"OpenSourceMalware check for {name}: {response.status_code}")
                    return None

            except httpx.TimeoutException:
                logger.debug(f"Timeout checking {name} against OpenSourceMalware")
                return None
            except httpx.ConnectError:
                logger.debug(f"Connection error checking {name} against OpenSourceMalware")
                return None
            except Exception as e:
                logger.debug(f"Exception checking {name} against OpenSourceMalware: {e}")
                return None

        # Use distributed lock to prevent multiple pods fetching same package
        result = await cache_service.get_or_fetch_with_lock(
            key=cache_key,
            fetch_fn=fetch_malware_status,
            ttl_seconds=CacheTTL.MALWARE_CHECK,
        )

        # Return None for empty results (negative cache)
        if not result:
            return None
        return result
