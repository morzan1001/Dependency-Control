"""
Vulnerability Enrichment Service

Enriches vulnerability findings with additional data from external sources:
- EPSS (Exploit Prediction Scoring System) from FIRST.org
- CISA KEV (Known Exploited Vulnerabilities) catalog
- Additional metadata for prioritization

Data Sources:
- EPSS API: https://api.first.org/data/v1/epss
- CISA KEV: https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json
"""

import asyncio
import logging
from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional, Set

import httpx

logger = logging.getLogger(__name__)


@dataclass
class EPSSData:
    """EPSS (Exploit Prediction Scoring System) data for a CVE."""
    cve: str
    epss_score: float  # Probability of exploitation in next 30 days (0.0 - 1.0)
    percentile: float  # Percentile rank among all CVEs
    date: str  # Date of the EPSS calculation


@dataclass
class KEVEntry:
    """CISA Known Exploited Vulnerability entry."""
    cve: str
    vendor_project: str
    product: str
    vulnerability_name: str
    date_added: str
    short_description: str
    required_action: str
    due_date: str
    known_ransomware_use: bool = False


@dataclass
class VulnerabilityEnrichment:
    """Enriched vulnerability data combining multiple sources."""
    cve: str
    
    # EPSS Data
    epss_score: Optional[float] = None  # 0.0 - 1.0, probability of exploitation
    epss_percentile: Optional[float] = None  # 0.0 - 100.0
    epss_date: Optional[str] = None
    
    # CISA KEV Data
    is_kev: bool = False  # Is in CISA Known Exploited Vulnerabilities catalog
    kev_date_added: Optional[str] = None
    kev_due_date: Optional[str] = None
    kev_required_action: Optional[str] = None
    kev_ransomware_use: bool = False
    
    # Computed fields
    exploit_maturity: str = "unknown"  # unknown, poc, active, weaponized
    risk_score: Optional[float] = None  # Combined risk score 0-100
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "cve": self.cve,
            "epss_score": self.epss_score,
            "epss_percentile": self.epss_percentile,
            "epss_date": self.epss_date,
            "is_kev": self.is_kev,
            "kev_date_added": self.kev_date_added,
            "kev_due_date": self.kev_due_date,
            "kev_required_action": self.kev_required_action,
            "kev_ransomware_use": self.kev_ransomware_use,
            "exploit_maturity": self.exploit_maturity,
            "risk_score": self.risk_score,
        }


class VulnerabilityEnrichmentService:
    """
    Service to enrich vulnerability data with EPSS scores and CISA KEV information.
    
    Uses caching to minimize API calls:
    - KEV catalog is cached for 24 hours (updates daily)
    - EPSS scores are cached for 24 hours
    """
    
    EPSS_API_URL = "https://api.first.org/data/v1/epss"
    KEV_CATALOG_URL = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
    
    CACHE_TTL_HOURS = 24
    EPSS_BATCH_SIZE = 100  # Max CVEs per EPSS API request
    
    def __init__(self):
        self._kev_cache: Dict[str, KEVEntry] = {}
        self._kev_cache_time: Optional[datetime] = None
        self._epss_cache: Dict[str, EPSSData] = {}
        self._epss_cache_time: Optional[datetime] = None
        self._http_client: Optional[httpx.AsyncClient] = None
    
    async def _get_client(self) -> httpx.AsyncClient:
        """Get or create HTTP client."""
        if self._http_client is None or self._http_client.is_closed:
            self._http_client = httpx.AsyncClient(timeout=30.0)
        return self._http_client
    
    async def close(self):
        """Close HTTP client."""
        if self._http_client and not self._http_client.is_closed:
            await self._http_client.aclose()
    
    def _is_cache_valid(self, cache_time: Optional[datetime]) -> bool:
        """Check if cache is still valid."""
        if cache_time is None:
            return False
        return datetime.now(timezone.utc) - cache_time < timedelta(hours=self.CACHE_TTL_HOURS)
    
    async def _load_kev_catalog(self) -> Dict[str, KEVEntry]:
        """Load CISA KEV catalog, using cache if valid."""
        if self._is_cache_valid(self._kev_cache_time):
            return self._kev_cache
        
        try:
            client = await self._get_client()
            response = await client.get(self.KEV_CATALOG_URL)
            response.raise_for_status()
            
            data = response.json()
            vulnerabilities = data.get("vulnerabilities", [])
            
            self._kev_cache = {}
            for vuln in vulnerabilities:
                cve = vuln.get("cveID", "")
                if cve:
                    self._kev_cache[cve] = KEVEntry(
                        cve=cve,
                        vendor_project=vuln.get("vendorProject", ""),
                        product=vuln.get("product", ""),
                        vulnerability_name=vuln.get("vulnerabilityName", ""),
                        date_added=vuln.get("dateAdded", ""),
                        short_description=vuln.get("shortDescription", ""),
                        required_action=vuln.get("requiredAction", ""),
                        due_date=vuln.get("dueDate", ""),
                        known_ransomware_use=vuln.get("knownRansomwareCampaignUse", "").lower() == "known",
                    )
            
            self._kev_cache_time = datetime.now(timezone.utc)
            logger.info(f"Loaded {len(self._kev_cache)} entries from CISA KEV catalog")
            
        except Exception as e:
            logger.warning(f"Failed to load CISA KEV catalog: {e}")
            # Return existing cache if available, even if expired
        
        return self._kev_cache
    
    async def _fetch_epss_batch(self, cves: List[str]) -> Dict[str, EPSSData]:
        """Fetch EPSS scores for a batch of CVEs."""
        if not cves:
            return {}
        
        try:
            client = await self._get_client()
            # EPSS API accepts comma-separated CVE list
            cve_param = ",".join(cves)
            response = await client.get(f"{self.EPSS_API_URL}?cve={cve_param}")
            response.raise_for_status()
            
            data = response.json()
            results = {}
            
            for entry in data.get("data", []):
                cve = entry.get("cve", "")
                if cve:
                    results[cve] = EPSSData(
                        cve=cve,
                        epss_score=float(entry.get("epss", 0)),
                        percentile=float(entry.get("percentile", 0)) * 100,  # Convert to percentage
                        date=entry.get("date", ""),
                    )
            
            return results
            
        except Exception as e:
            logger.warning(f"Failed to fetch EPSS data for {len(cves)} CVEs: {e}")
            return {}
    
    async def _load_epss_scores(self, cves: List[str]) -> Dict[str, EPSSData]:
        """Load EPSS scores for given CVEs, using cache where available."""
        result = {}
        missing_cves = []
        
        # Check cache first
        for cve in cves:
            if cve in self._epss_cache:
                result[cve] = self._epss_cache[cve]
            else:
                missing_cves.append(cve)
        
        # Fetch missing in batches
        if missing_cves:
            for i in range(0, len(missing_cves), self.EPSS_BATCH_SIZE):
                batch = missing_cves[i:i + self.EPSS_BATCH_SIZE]
                batch_results = await self._fetch_epss_batch(batch)
                
                # Update cache and results
                for cve, data in batch_results.items():
                    self._epss_cache[cve] = data
                    result[cve] = data
                
                # Small delay between batches to be nice to the API
                if i + self.EPSS_BATCH_SIZE < len(missing_cves):
                    await asyncio.sleep(0.5)
        
        return result
    
    def _calculate_exploit_maturity(
        self, 
        is_kev: bool, 
        kev_ransomware: bool,
        epss_score: Optional[float]
    ) -> str:
        """
        Determine exploit maturity level.
        
        Levels:
        - weaponized: Active ransomware use
        - active: In CISA KEV (confirmed active exploitation)
        - high: EPSS > 0.1 (10% chance of exploitation)
        - medium: EPSS > 0.01 (1% chance)
        - low: EPSS <= 0.01
        - unknown: No data
        """
        if kev_ransomware:
            return "weaponized"
        if is_kev:
            return "active"
        if epss_score is not None:
            if epss_score > 0.1:
                return "high"
            if epss_score > 0.01:
                return "medium"
            return "low"
        return "unknown"
    
    def _calculate_risk_score(
        self,
        cvss_score: Optional[float],
        epss_score: Optional[float],
        is_kev: bool,
        kev_ransomware: bool,
    ) -> float:
        """
        Calculate a combined risk score (0-100) considering:
        - CVSS score (severity)
        - EPSS score (likelihood of exploitation)
        - KEV status (confirmed exploitation)
        
        Formula:
        - Base: CVSS normalized to 0-60
        - EPSS bonus: up to +20 points
        - KEV bonus: +15 points
        - Ransomware bonus: +5 points
        """
        score = 0.0
        
        # CVSS contribution (0-60 points)
        if cvss_score is not None:
            score += (cvss_score / 10.0) * 60
        else:
            # Default to medium if no CVSS
            score += 30
        
        # EPSS contribution (0-20 points)
        if epss_score is not None:
            # EPSS is already 0-1, multiply by 100 for percentage
            # High EPSS (>0.5) gets full 20 points
            epss_contribution = min(epss_score * 2, 1.0) * 20
            score += epss_contribution
        
        # KEV bonus
        if is_kev:
            score += 15
        
        # Ransomware bonus
        if kev_ransomware:
            score += 5
        
        return min(score, 100.0)
    
    async def enrich_cves(
        self, 
        cves: List[str],
        cvss_scores: Optional[Dict[str, float]] = None,
    ) -> Dict[str, VulnerabilityEnrichment]:
        """
        Enrich a list of CVEs with EPSS and KEV data.
        
        Args:
            cves: List of CVE IDs to enrich
            cvss_scores: Optional dict of CVE -> CVSS score for risk calculation
            
        Returns:
            Dict mapping CVE ID to VulnerabilityEnrichment
        """
        if not cves:
            return {}
        
        # Deduplicate and filter valid CVE IDs
        unique_cves = list(set(cve for cve in cves if cve and cve.startswith("CVE-")))
        
        if not unique_cves:
            return {}
        
        cvss_scores = cvss_scores or {}
        
        # Load data sources in parallel
        kev_task = self._load_kev_catalog()
        epss_task = self._load_epss_scores(unique_cves)
        
        kev_catalog, epss_data = await asyncio.gather(kev_task, epss_task)
        
        # Build enrichment for each CVE
        results = {}
        for cve in unique_cves:
            kev_entry = kev_catalog.get(cve)
            epss_entry = epss_data.get(cve)
            cvss = cvss_scores.get(cve)
            
            is_kev = kev_entry is not None
            kev_ransomware = kev_entry.known_ransomware_use if kev_entry else False
            epss_score = epss_entry.epss_score if epss_entry else None
            
            enrichment = VulnerabilityEnrichment(
                cve=cve,
                epss_score=epss_score,
                epss_percentile=epss_entry.percentile if epss_entry else None,
                epss_date=epss_entry.date if epss_entry else None,
                is_kev=is_kev,
                kev_date_added=kev_entry.date_added if kev_entry else None,
                kev_due_date=kev_entry.due_date if kev_entry else None,
                kev_required_action=kev_entry.required_action if kev_entry else None,
                kev_ransomware_use=kev_ransomware,
                exploit_maturity=self._calculate_exploit_maturity(is_kev, kev_ransomware, epss_score),
                risk_score=self._calculate_risk_score(cvss, epss_score, is_kev, kev_ransomware),
            )
            
            results[cve] = enrichment
        
        logger.info(f"Enriched {len(results)} CVEs (KEV: {sum(1 for e in results.values() if e.is_kev)}, EPSS: {sum(1 for e in results.values() if e.epss_score is not None)})")
        
        return results
    
    async def enrich_findings(
        self, 
        findings: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """
        Enrich a list of vulnerability findings with EPSS and KEV data.
        Modifies findings in-place and returns them.
        
        Args:
            findings: List of finding dicts with 'id' field containing CVE ID
            
        Returns:
            Same list with enrichment data added to each finding
        """
        if not findings:
            return findings
        
        # Extract CVE IDs and CVSS scores
        cve_to_findings: Dict[str, List[Dict[str, Any]]] = {}
        cvss_scores: Dict[str, float] = {}
        
        for finding in findings:
            cve = finding.get("finding_id") or finding.get("id", "")
            if cve and cve.startswith("CVE-"):
                if cve not in cve_to_findings:
                    cve_to_findings[cve] = []
                cve_to_findings[cve].append(finding)
                
                # Extract CVSS from details if available
                details = finding.get("details", {})
                if isinstance(details, dict):
                    # Try to get CVSS from vulnerabilities array
                    vulns = details.get("vulnerabilities", [])
                    for vuln in vulns:
                        if vuln.get("id") == cve and vuln.get("cvss_score"):
                            cvss_scores[cve] = vuln["cvss_score"]
                            break
                    # Or directly from finding
                    if cve not in cvss_scores and details.get("cvss_score"):
                        cvss_scores[cve] = details["cvss_score"]
            
            # Also check aliases
            for alias in finding.get("aliases", []):
                if alias.startswith("CVE-") and alias not in cve_to_findings:
                    cve_to_findings[alias] = []
                    # Don't duplicate the finding, just note we should fetch this CVE
        
        if not cve_to_findings:
            return findings
        
        # Enrich CVEs
        enrichments = await self.enrich_cves(list(cve_to_findings.keys()), cvss_scores)
        
        # Apply enrichment to findings
        for cve, enrichment in enrichments.items():
            for finding in cve_to_findings.get(cve, []):
                # Add enrichment data to finding details
                if "details" not in finding:
                    finding["details"] = {}
                
                finding["details"]["enrichment"] = enrichment.to_dict()
                
                # Also add top-level fields for easy access
                finding["epss_score"] = enrichment.epss_score
                finding["epss_percentile"] = enrichment.epss_percentile
                finding["is_kev"] = enrichment.is_kev
                finding["exploit_maturity"] = enrichment.exploit_maturity
                finding["risk_score"] = enrichment.risk_score
        
        return findings


# Singleton instance
vulnerability_enrichment_service = VulnerabilityEnrichmentService()


async def enrich_vulnerability_findings(findings: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Convenience function to enrich findings."""
    return await vulnerability_enrichment_service.enrich_findings(findings)


async def get_cve_enrichment(cves: List[str]) -> Dict[str, VulnerabilityEnrichment]:
    """Convenience function to get enrichment for CVE list."""
    return await vulnerability_enrichment_service.enrich_cves(cves)
